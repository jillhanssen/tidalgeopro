""" Skeleton.

Compute the skeleton of a tidal channel network.

Author: Olivier Gourgue (University of Antwerp & Boston University)

"""

import numpy as np
import shapely as shp
import time

import centerline.geometry


################################################################################
# Raw skeleton. ################################################################
################################################################################

def raw_skeleton(mpol):
    """Compute the center line of a tidal channel network.

    Args:
        mpol (MultiPolygon): Tidal channel network.

    Returns:
        List of MultiLineStrings: Raw skeleton. There is one raw skeleton
            MultilineString per tidal channel network Polygon.
    """

    print('')
    print('Computing the raw skeleton can be a long process.')
    print('')

    # Start timer.
    start = time.time()

    # Compute raw skeleton, as center line of the tidal channel network. All
    # segments (LineStrings of two Points) generated by Centerline are merged
    # into longer LineStrings using linemerge from Shapely operations.
    skls = []
    for pol in mpol.geoms:
        skls.append(shp.ops.linemerge(centerline.geometry.Centerline(pol)))

    # Print time.
    print('Raw skeleton computed in %.2f seconds.' % (time.time() - start))
    print('')

    return skls


################################################################################
# Clean skeleton. ##############################################################
################################################################################

def clean_skeleton(skls, mpol, ratio = 1):
    """Clean the raw skeleton by removing small channel head sections.

    Args:
        skls (list of MultiLineStrings): Raw skeleton.
        mpol (MultiPolygon): Tidal channel network.
        ratio (float): Threshold ratio (section length / distance between
            downstream node and channel banks). Channel head sections with lower
            ratio are removed. Default to 1.

    Returns:
        List of MultiLineStrings: Clean skeleton. There is one clean skeleton
            MultilineString per tidal channel network Polygon.
    """

    # Remove small channel head sections.
    # Loop over tidal channel networks.
    for i in range(len(mpol.geoms)):
        # Tidal channel network.
        pol = mpol.geoms[i]
        # Raw skeleton.
        skl = skls[i]
        # Loop as long as there are channel head sections to remove.
        while True:
            # Convert MultiLineString into list of LineStrings.
            lss = []
            for ls in skl.geoms:
                lss.append(ls)
            # Indices of channel sections to remove.
            ind = []
            # Loop over channel sections.
            for j in range(len(skl.geoms)):
                # Channel section.
                ls = skl.geoms[j]
                # Remaining skeleton.
                skl0 = shp.geometry.MultiLineString(lss[:j] + lss[j + 1:])
                # Channel section nodes.
                p0 = shp.geometry.Point(ls.coords[0])
                p1 = shp.geometry.Point(ls.coords[-1])
                # Distance between channel section nodes and remaining skeleton.
                d0 = p0.distance(skl0)
                d1 = p1.distance(skl0)
                # Test if this is a channel head section.
                if d0 > 0 or d1 > 0:
                    # Downstream channel section node.
                    if d0 == 0:
                        pd = p0
                    else:
                        pd = p1
                    # Distance between downstream channel section node and
                    # channel banks.
                    d = pd.distance(pol.exterior)
                    for interior in pol.interiors:
                        if pd.distance(interior) < d:
                            d = pd.distance(interior)
                    # Test if the channel head section must be removed.
                    if ls.length / d < ratio:
                        ind.append(j)
            # Test if there are channel head sections to remove.
            if len(ind) > 0:
                # Remove them and merge remaining sections.
                lss = []
                for j in range(len(skl.geoms)):
                    if j not in ind:
                        lss.append(skl.geoms[j])
                skl = shp.ops.linemerge(shp.geometry.MultiLineString(lss))
                # Convert skeleton into MultiLineString if necessary.
                if skl.type == 'LineString':
                    skl = shp.geometry.MultiLineString([skl])
            else:
                # Update raw skeleton.
                skls[i] = skl
                # End loop.
                break

    return skls


################################################################################
# Final skeleton. ##############################################################
################################################################################

def final_skeleton(skls, mpol, mls, dx, zero = 1e-3, smin = 0):

    # Split skeletons at downstream LineStrings.
    # Loop over skeletons.
    for i in range(len(skls)):
        # Skeleton.
        skl = skls[i]
        # Initialize split skeleton as empty list of LineStrings.
        lss0 = []
        # Downstream LineString.
        dls = mls.geoms[i]
        # Loop over channel sections.
        for j in range(len(skl.geoms)):
            # Channel section.
            ls = skl.geoms[j]
            # Test if channel section can be split by downstream LineString.
            if ls.crosses(dls):
                # Split LineString and add split LineStrings to split skeleton.
                split_lss = shp.ops.split(ls, dls)
                for split_ls in split_lss:
                    lss0.append(split_ls)
            else:
                # Add non-split LineString to split skeleton.
                lss0.append(ls)
        # Update skeleton.
        skls[i] = shp.geometry.MultiLineString(lss0)

    # Remove channel sections downstream the downstream LineString and merge
    # skeletons into one MultiLineString.
    # Initialize list of channel sections.
    lss = []
    # Loop over skeletons.
    for i in range(len(skls)):
        # Skeleton.
        skl = skls[i]
        # Channel network Polygon.
        pol = mpol.geoms[i]
        # Initialize split channel network polygons as empty list of polygons.
        pols0 = [] # Polygons with channel sections removed.
        pols1 = [] # Open water Polygon removed.
        # Downstream LineString.
        dls = mls.geoms[i]
        # Split channel network polygon.
        split_pols = shp.ops.split(pol, dls)
        # Remove split polygons with no channel section inside and smaller than
        # the minimum surface area.
        for split_pol in split_pols.geoms:
            if split_pol.area > smin:
                for ls in skl.geoms:
                    if ls.intersects(split_pol):
                        pols0.append(split_pol)
                        break
        # In case of 2 remaining Polygons, keep only the largest one.
        if len(pols0) == 2:
            if pols0[0].area > pols0[1].area:
                pols1.append(pols0[0])
            else:
                pols1.append(pols0[1])
        # In case of more than 2 remaining Polygons, remove the polygon that
        # intersects all the other ones (open water).
        else:
            for j in range(len(pols0)):
                intersect = np.zeros(len(pols0), dtype = bool)
                polj = pols0[j]
                for k in range(len(pols0)):
                    polk = pols0[k]
                    intersect[k] = polj.intersects(polk)
                # Test if split polygon is connected to the others.
                if not np.all(intersect):
                    pols1.append(polj)
        # Keep the channel sections inside split channel network polygons.
        for ls in skl.geoms:
            for pol1 in pols1:
                # Test if channel section is within channel network polygon.
                if ls.within(pol1):
                    lss.append(ls)
                # If not, it might be the most downstream channel with the
                # downstream node slightly outside the channel network polygon
                # due to rounding errors.
                else:
                    # Check which node is upstream and test if it is within the
                    # channel network polygon.
                    x, y = ls.xy
                    p0 = shp.geometry.Point((x[0], y[0]))
                    p1 = shp.geometry.Point((x[-1], y[-1]))
                    if p0.distance(dls) > p1.distance(dls):
                        if p0.within(pol1):
                            lss.append(ls)
                    else:
                        if p1.within(pol1):
                            lss.append(ls)

    # Skeleton node coordinates.
    node_xy = []
    for ls in lss:
        for coords in [ls.coords[0], ls.coords[-1]]:
            if coords not in node_xy:
                node_xy.append(coords)
    node_xy = np.array(node_xy)

    # Skeleton section connectivity table.
    node_sections = np.zeros((len(lss), 2), dtype = int)
    for i in range(len(lss)):
        ls = lss[i]
        n0 = int(np.argwhere(np.all(node_xy == ls.coords[0], axis = 1)))
        n1 = int(np.argwhere(np.all(node_xy == ls.coords[-1], axis = 1)))
        node_sections[i, 0] = n0
        node_sections[i, 1] = n1

    # Downstream node indices.
    dns = []
    for i in range(node_xy.shape[0]):
        # Test if distance between channel section node and downstream
        # LineString is zero (taking rounding errors into account).
        x, y = node_xy[i, :]
        if shp.geometry.Point((x, y)).distance(dls) < zero:
            dns.append(i)

    # Compute downstream length at skeleton nodes and reorganize skeleton.
    (node_xy,
     node_sections,
     node_dl,
     lss) = donwstream_length(node_xy, node_sections, lss, dns)

    # Compute final skeleton by (i) removing channel sections and skeleton nodes
    # that have not been connected to the main skeleton, and (ii) redefining
    # skeleton points at regular distance from each other.

    # Initialize lists.
    node_xy_new = []
    node_sections_new = []
    node_dl_new = []
    skl_xy = []
    skl_sections = []
    skl_dl = []
    lss_new = []

    # Loop over old channel sections.
    for s in range(len(lss)):
        # Old node indices and corresponding downstream lengths.
        n0 = node_sections[s, 0]
        n1 = node_sections[s, 1]
        node_dl0 = node_dl[n0]
        node_dl1 = node_dl[n1]
        # Only keep channel sections connected to the main skeleton.
        if np.isfinite(node_dl0) and np.isfinite(node_dl1):

            # Update node lists by removing channel sections and skeleton nodes
            # that have not been connected to the main skeleton.

            # Update node lists for first node.
            node_xy0 = list(node_xy[n0, :])
            if node_xy0 in node_xy_new:
                node_sections_new.append([node_xy_new.index(node_xy0)])
            else:
                node_xy_new.append(node_xy0)
                node_sections_new.append([len(node_xy_new) - 1])
                node_dl_new.append(node_dl0)
            # Update node lists for last node.
            node_xy1 = list(node_xy[n1, :])
            if node_xy1 in node_xy_new:
                node_sections_new[-1].append(node_xy_new.index(node_xy1))
            else:
                node_xy_new.append(node_xy1)
                node_sections_new[-1].append(len(node_xy_new) - 1)
                node_dl_new.append(node_dl1)

            # Redefine skeleton points at regular distance from each other.

            # Downstream length at extreme regular points of the channel
            # section.
            skl_dl_loc_0 = np.ceil(node_dl0 / dx) * dx
            skl_dl_loc_1 = np.floor(node_dl1 / dx) * dx
            # Update regular skeleton point coordinates, sections and downstream
            # lengths.
            for skl_dl_loc in np.arange(skl_dl_loc_0, skl_dl_loc_1 + dx, dx):
                point = lss[s].interpolate(skl_dl_loc - node_dl0)
                skl_xy.append([point.x, point.y])
                skl_dl.append(skl_dl_loc)
                skl_sections.append(len(node_sections_new) - 1)

    # Convert lists into arrays.
    node_xy = np.array(node_xy_new)
    node_sections = np.array(node_sections_new)
    node_dl = np.array(node_dl_new)
    skl_xy = np.array(skl_xy)
    skl_sections = np.array(skl_sections)
    skl_dl = np.array(skl_dl)

    return node_xy, node_sections, node_dl, skl_xy, skl_sections, skl_dl


################################################################################
# Downstream length. ###########################################################
################################################################################

def donwstream_length(node_xy, node_sections, lss, dns):

    # Initialize buffer list with downstream section indices.
    buf = []
    for dn in dns:
        buf.append(np.argwhere(node_sections == dn).reshape(-1)[0])

    # Channel section lengths.
    lens = np.zeros(node_sections.shape[0])
    for i in range(lens.shape[0]):
        lens[i] = lss[i].length

    # Initialize downstream length at skeleton nodes.
    node_dl = np.zeros(node_xy.shape[0]) + np.inf
    # Loop over channel sections in the buffer list.
    for i in range(len(buf)):
        # Section index.
        s = buf[i]
        # Downstream node index.
        nd = dns[i]
        # Upstream node index.
        if nd == node_sections[s, 0]:
            nu = node_sections[s, 1]
        else:
            nu = node_sections[s, 0]
        # Update downstream length at channel section nodes.
        node_dl[nd] = 0
        node_dl[nu] = lens[s]
        # Update channel section and LineString orientation.
        if nd != node_sections[s, 0]:
            node_sections[s, 0] = nd
            node_sections[s, 1] = nu
            ls_coords = list(lss[s].coords)
            ls_coords.reverse()
            lss[s] = shp.geometry.LineString(ls_coords)

    # Loop as long as the buffer list is not empty.
    while len(buf) > 0:
        # Initialize list of connected channel sections.
        con = []
        # Loop over channel sections in the buffer list.
        for s in buf:
            # Channel section nodes.
            n0 = node_sections[s, 0]
            n1 = node_sections[s, 1]
            # Look for connected channel sections.
            for n in [n0, n1]:
                ind = list(np.argwhere(node_sections == n)[:, 0])
                for nc in ind:
                    if nc != s:
                        con.append(nc)
        # Reset buffer list.
        buf = []
        # Loop over connected channel sections.
        for s in con:
            # Channel section nodes.
            n0 = node_sections[s, 0]
            n1 = node_sections[s, 1]
            # If downstream length at channel section nodes is lower than
            # previous value, update value and add channel section to buffer
            # list.
            node_dl0 = node_dl[n1] + lens[s]
            node_dl1 = node_dl[n0] + lens[s]
            if node_dl0 < node_dl[n0]:
                node_dl[n0] = node_dl0
                buf.append(s)
            if node_dl1 < node_dl[n1]:
                node_dl[n1] = node_dl1
                buf.append(s)
            # If downstream length if higher at downstream nodes vs. upstream
            # nodes, update channel section and LineString orientation.
            for s in range(node_sections.shape[0]):
                n0 = node_sections[s, 0]
                n1 = node_sections[s, 1]
                node_dl0 = node_dl[n0]
                node_dl1 = node_dl[n1]
                if node_dl1 < node_dl0:
                    node_sections[s, 0] = n1
                    node_sections[s, 1] = n0
                    ls_coords = list(lss[s].coords)
                    ls_coords.reverse()
                    lss[s] = shp.geometry.LineString(ls_coords)

    # Split channel sections at maximum downstream length.
    # Initialize list of channel sections to delete.
    trash = []
    # Loop over channel sections.
    for s in range(node_sections.shape[0]):
        # Channel section nodes.
        n0 = node_sections[s][0]
        n1 = node_sections[s][1]
        # Test if channel section length is higher than the difference between
        # upstream length at channel section nodes.
        if lens[s] - np.abs(node_dl[n1] - node_dl[n0]) > 1e-6:
            # Maximum downstream length on that channel section and
            # corresponding skeleton point.
            dl_max = .5 * (lens[s] + node_dl[n0] + node_dl[n1])
            p_max = lss[s].interpolate(dl_max - node_dl[n0])
            n_max = node_xy.shape[0]
            # Split LineString at point of maximum downstream length.
            # Loop over channel section points.
            for i in range(len(lss[s].coords)):
                # Channel section point.
                pi = shp.geometry.Point(lss[s].coords[i])
                # Case of split point exactly on a channel section point.
                if lss[s].project(pi) == dl_max - node_dl[n0]:
                    node_xy = np.append(node_xy, [[p_max.x, p_max.y]], axis = 0)
                    node_dl = np.append(node_dl, dl_max)
                    node_sections = np.append(node_sections, [[n0, n_max]],
                                              axis = 0)
                    node_sections = np.append(node_sections, [[n1, n_max]],
                                              axis = 0)
                    lss.append(shp.geometry.LineString(lss[s].coords[:i + 1]))
                    lss.append(shp.geometry.LineString(lss[s].coords[i:]))
                    trash.append(s)
                    break
                # Case of split point between two channel section points.
                if lss[s].project(pi) > dl_max - node_dl[n0]:
                    node_xy = np.append(node_xy, [[p_max.x, p_max.y]], axis = 0)
                    node_dl = np.append(node_dl, dl_max)
                    node_sections = np.append(node_sections, [[n0, n_max]],
                                              axis = 0)
                    node_sections = np.append(node_sections, [[n1, n_max]],
                                              axis = 0)
                    lss.append(shp.geometry.LineString(lss[s].coords[:i] +
                                                       [(p_max.x, p_max.y)]))
                    lss.append(shp.geometry.LineString([(p_max.x, p_max.y)] +
                                                       lss[s].coords[i:]))
                    trash.append(s)
                    break
    # Delete original split channel sections.
    trash.reverse()
    for s in trash:
        node_sections = np.delete(node_sections, s, axis = 0)
        del lss[s]

    return node_xy, node_sections, node_dl, lss
