""" Skeleton.

Compute the skeleton of a tidal channel network.

Author: Olivier Gourgue (University of Antwerp & Boston University)

"""

import numpy as np
import shapely as shp
import time

import centerline.geometry


################################################################################
# Raw skeleton. ################################################################
################################################################################

def raw_skeleton(mpol):
    """Compute the center line of a tidal channel network.

    Args:
        mpol (Polygon or MultiPolygon): Tidal channel network.

    Returns:
        MultiLineString or list of MultiLineStrings: Raw skeleton. There is one
            raw skeleton MultilineString per tidal channel network Polygon.
    """

    print('')
    print('Computing the raw skeleton can be a long process.')
    print('')

    # Start timer.
    start = time.time()

    # If the tidal channel network is a Polygon, convert into MultiPolygon.
    if mpol.geom_type == 'Polygon':
        mpol = shp.geometry.MultiPolygon([mpol])

    # Compute raw skeleton, as center line of the tidal channel network. All
    # segments (LineStrings of two Points) generated by Centerline are merged
    # into longer LineStrings using linemerge from Shapely operations.
    skls = []
    for pol in mpol.geoms:
        skls.append(shp.ops.linemerge(centerline.geometry.Centerline(pol)))

    # Print time.
    print('Raw skeleton computed in %.2f seconds.' % (time.time() - start))
    print('')

    # Return the raw skeleton as a MultiLineString or a list of MultiLineStrings
    # depending if the tidal channel network is a Polygon or a MultiPolygon.
    if len(skls) == 1:
        return skls[0]
    else:
        return skls


################################################################################
# Clean skeleton. ##############################################################
################################################################################

def clean_skeleton(skls, mpol, ratio = 1):
    """Clean the raw skeleton by removing small channel head sections.

    Args:
        skls (MultiLineString or list of MultiLineStrings): Raw skeleton.
        mpol (Polygon or MultiPolygon): Tidal channel network.
        ratio (float): Threshold ratio (section length / distance between
            downstream node and channel banks). Channel head sections with lower
            ratio are removed. Default to 1.

    Returns:
        MultiLineString or list of MultiLineStrings: Clean skeleton. There is
            one clean skeleton MultilineString per tidal channel network
            Polygon.
    """

    # If the raw skeleton is a MultiLineString, convert into a list of
    # MultiLineStrings.
    if type(skls) != list:
        skls = [skls]

    # If the tidal channel network is a Polygon, convert into MultiPolygon.
    if mpol.geom_type == 'Polygon':
        mpol = shp.geometry.MultiPolygon([mpol])

    # Remove small channel head sections.
    # Loop over tidal channel networks.
    for i in range(len(mpol.geoms)):
        # Tidal channel network.
        pol = mpol.geoms[i]
        # Raw skeleton.
        skl = skls[i]
        # Loop as long as there are channel head sections to remove.
        while True:
            # Convert MultiLineString into list of LineStrings.
            lss = []
            for ls in skl.geoms:
                lss.append(ls)
            # Indices of channel sections to remove.
            ind = []
            # Loop over channel sections.
            for j in range(len(skl.geoms)):
                # Channel section.
                ls = skl.geoms[j]
                # Remaining skeleton.
                skl0 = shp.geometry.MultiLineString(lss[:j] + lss[j + 1:])
                # Channel section nodes.
                p0 = shp.geometry.Point(ls.coords[0])
                p1 = shp.geometry.Point(ls.coords[-1])
                # Distance between channel section nodes and remaining skeleton.
                d0 = p0.distance(skl0)
                d1 = p1.distance(skl0)
                # Test if this is a channel head section.
                if d0 > 0 or d1 > 0:
                    # Downstream channel section node.
                    if d0 == 0:
                        pd = p0
                    else:
                        pd = p1
                    # Distance between downstream channel section node and
                    # channel banks.
                    d = pd.distance(pol.exterior)
                    for interior in pol.interiors:
                        if pd.distance(interior) < d:
                            d = pd.distance(interior)
                    # Test if the channel head section must be removed.
                    if ls.length / d < ratio:
                        ind.append(j)
            # Test if there are channel head sections to remove.
            if len(ind) > 0:
                # Remove them and merge remaining sections.
                lss = []
                for j in range(len(skl.geoms)):
                    if j not in ind:
                        lss.append(skl.geoms[j])
                skl = shp.ops.linemerge(shp.geometry.MultiLineString(lss))
            else:
                # Update raw skeleton.
                skls[i] = skl
                # End loop.
                break

    # Return. Clean tidal channel netwrok is of the same data type than the
    # original tidal channel network (either Polygon or MultiPolygon).
    if len(mpol.geoms) == 1:
        return skls[0]
    else:
        return skls


################################################################################
# Final skeleton. ##############################################################
################################################################################

def final_skeleton(skls, mpol, mls, dx = 1):

    # If the clean skeleton is a MultiLineString, convert into a list of one
    # MultiLineString.
    if type(skls) != list:
        skls = [skls]

    # If the tidal channel network is a Polygon, convert into MultiPolygon.
    if mpol.geom_type == 'Polygon':
        mpol = shp.geometry.MultiPolygon([mpol])

    # If only one LineString to define the downstream limit of the skeleton,
    # convert into MultiLineString.
    if mls.geom_type == 'LineString':
        mls = shp.geometry.MultiLineString([mls])

    # Split skeletons at downstream LineStrings.
    # Loop over skeletons.
    for i in range(len(skls)):
        # Skeleton.
        skl = skls[i]
        # Downstream LineString.
        dls = mls.geoms[i]
        # Loop over channel sections.
        for j in range(len(skl.geoms)):
            # Channel section.
            ls = skl.geoms[j]
            # Test if channel section can be split by downstream LineString.
            if ls.crosses(dls):
                # Remaining skeleton.
                lss0 = []
                for k in range(len(skl.geoms)):
                    if j != k:
                        lss0.append(skl.geoms[k])
                skl0 = shp.geometry.MultiLineString(lss0)
                # Split downstream channel section.
                split_lss = shp.ops.split(skl, dls)
                # Keep split channel section connected to the remaining
                # skeleton.
                for split_ls in split_lss:
                    if split_ls.distance(skl0) == 0:
                        lss0.append(split_ls)
                # Update skeleton.
                skls[i] = shp.geometry.MultiLineString(lss0)
                # Break loop over channels.
                break

    # Merge skeletons into one MultiLineString.
    lss = []
    for skl in skls:
        for ls in skl.geoms:
            lss.append(ls)
    skl = shp.geometry.MultiLineString(lss)

    # Skeleton node coordinates.
    node_xy = []
    for ls in skl.geoms:
        for coords in [ls.coords[0], ls.coords[-1]]:
            if coords not in node_xy:
                node_xy.append(coords)
    node_xy = np.array(node_xy)

    # Skeleton section connectivity table.
    node_sections = np.zeros((len(skl.geoms), 2), dtype = int)
    for i in range(len(skl.geoms)):
        ls = skl.geoms[i]
        n0 = int(np.argwhere(np.all(node_xy == ls.coords[0], axis = 1)))
        n1 = int(np.argwhere(np.all(node_xy == ls.coords[-1], axis = 1)))
        node_sections[i, 0] = n0
        node_sections[i, 1] = n1

    # Downstream node indices.

    # Compute downstream length at skeleton nodes and reorganize skeleton.
    """node_dl, node_xy, node_sexctions, skl = donwstream_length(node_xy, node_sexctions, skl, dn)"""

    # Compute final skeleton.

    return node_xy, node_sections, skl


################################################################################
# Downstream length. ###########################################################
################################################################################

def donwstream_length(node_xy, node_sexctions, skl, dn):

    # For the future docstring.
    # Compute downstream length at skeleton nodes and reorganize skeleton so
    # that (i) channel sections are oriented from downstream to
    # upstream and (ii) channel sections are split at maximum downstream length.




    # Loop over tidal channel networks.
    for i in range(len(skls)):
        # Channel network skeleton.
        skl = skls[i]
